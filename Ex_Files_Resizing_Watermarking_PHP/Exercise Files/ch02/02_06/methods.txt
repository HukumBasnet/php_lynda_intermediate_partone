public function outputImages($destination)
{
    if (!is_dir($destination) || !is_writable($destination)) {
        throw new \Exception('The destination must be a writable directory.');
    }
    $this->destination = $destination;
    // Loop through the source images
    foreach ($this->images as $i => $img) {
        // Skip files that are invalid
        if (in_array($this->images[$i]['file'], $this->invalid)) {
            continue;
        }
        // Create an image resource for the current image
        $resource = $this->createImageResource($this->images[$i]['file'], $this->images[$i]['type']);
        // Add a watermark if the $watermark property contains a value
        if ($this->watermark) {
            $this->addWatermark($this->images[$i], $resource);
        }
        // Delegate the generation of output to another method
        $this->generateOutput($this->images[$i], $resource);
        imagedestroy($resource);
    }
    // Return arrays of output and invalid files
    return ['output' => $this->generated, 'invalid' => $this->invalid];
}

protected function generateOutput($image, $resource)
{
    // Store the $outputSizes in a temporary variable
    $storedSizes = $this->outputSizes;
    // Get the constituent parts of the current file name
    $nameParts = pathinfo($image['file']);
    // Use imagescale() if supported
    if ($this->useImageScale) {
        // Recalculate $outputSizes if the image's height is greater than its width
        if ($this->useLongerDimension && imagesy($resource) > imagesx($resource)) {
            $this->recalculateSizes($resource);
        }
        foreach ($this->outputSizes as $outputSize) {
            // Don't resize if current output size is greater than the original
            if ($outputSize >= $image['w']) {
                continue;
            }
            $scaled = imagescale($resource, $outputSize, -1, $this->resample);
            $filename = $nameParts['filename'] . '_' . $outputSize . '.' . $nameParts['extension'];
            // Delegate file output to specialized method
            $this->outputFile($scaled, $image['type'], $filename);
        }
    } else {
        // Use imagecopyresampled() if imagescale() is not supported
        foreach ($image['ratios'] as $ratio) {
            $w = round($image['w'] * $ratio);
            $h = round($image['h'] * $ratio);
            $filename = $nameParts['filename'] . '_' . $w . '.' . $nameParts['extension'];
            $scaled = imagecreatetruecolor($w, $h);
            imagecopyresampled($scaled, $resource, 0, 0, 0, 0, $w, $h, $image['w'], $image['h']);
            $this->outputFile($scaled, $image['type'], $filename);
        }
    }
    // Reassign temporarily stored sizes to the $outputSizes property
    $this->outputSizes = $storedSizes;
}

protected function recalculateSizes($resource)
{
    // Get the width and height of the image resource
    $w = imagesx($resource);
    $h = imagesy($resource);
    foreach ($this->outputSizes as &$size) {
        // Multiply the size by the width divided by the height
        // Setting the second argument of round() to -1 rounds to the nearest multiple of 10
        $size = round($size * $w / $h, -1);
    }
}

protected function outputFile($scaled, $type, $name)
{
    $success = false;
    $outputFile = $this->destination . DIRECTORY_SEPARATOR . $name;
    switch ($type) {
        case 'image/jpeg':
            $success = imagejpeg($scaled, $outputFile, $this->jpegQuality);
            break;
        case 'image/png':
            $success = imagepng($scaled, $outputFile, $this->pngCompression);
            break;
        case 'image/gif':
            $success = imagegif($scaled, $outputFile);
            break;
        case 'image/webp':
            $success = imagewebp($scaled, $outputFile);
    }
    imagedestroy($scaled);
    if ($success) {
        $this->generated[] = $outputFile;
    }
}